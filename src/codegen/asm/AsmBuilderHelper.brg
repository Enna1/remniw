%{
#include "AsmBuilder.h"
#define DEBUG_TYPE "remniw-AsmBuilderHelper"
%}

# Do not delete the following lines
# The content of BrgTerm.gen will be inserted here during cmake
# %term define begin
%term BRG_UNDEF
%term BRG_CONST
%term BRG_LABEL
%term BRG_ARGS
%term BRG_REG
%term BRG_RET
%term BRG_BR
%term BRG_SWITCH
%term BRG_INDIRECTBR
%term BRG_INVOKE
%term BRG_RESUME
%term BRG_UNREACHABLE
%term BRG_CLEANUPRET
%term BRG_CATCHRET
%term BRG_CATCHSWITCH
%term BRG_CALLBR
%term BRG_FNEG
%term BRG_ADD
%term BRG_FADD
%term BRG_SUB
%term BRG_FSUB
%term BRG_MUL
%term BRG_FMUL
%term BRG_UDIV
%term BRG_SDIV
%term BRG_FDIV
%term BRG_UREM
%term BRG_SREM
%term BRG_FREM
%term BRG_SHL
%term BRG_LSHR
%term BRG_ASHR
%term BRG_AND
%term BRG_OR
%term BRG_XOR
%term BRG_ALLOCA
%term BRG_LOAD
%term BRG_STORE
%term BRG_GETELEMENTPTR
%term BRG_FENCE
%term BRG_ATOMICCMPXCHG
%term BRG_ATOMICRMW
%term BRG_TRUNC
%term BRG_ZEXT
%term BRG_SEXT
%term BRG_FPTOUI
%term BRG_FPTOSI
%term BRG_UITOFP
%term BRG_SITOFP
%term BRG_FPTRUNC
%term BRG_FPEXT
%term BRG_PTRTOINT
%term BRG_INTTOPTR
%term BRG_BITCAST
%term BRG_ADDRSPACECAST
%term BRG_CLEANUPPAD
%term BRG_CATCHPAD
%term BRG_ICMP
%term BRG_FCMP
%term BRG_PHI
%term BRG_CALL
%term BRG_SELECT
%term BRG_USEROP1
%term BRG_USEROP2
%term BRG_VAARG
%term BRG_EXTRACTELEMENT
%term BRG_INSERTELEMENT
%term BRG_SHUFFLEVECTOR
%term BRG_EXTRACTVALUE
%term BRG_INSERTVALUE
%term BRG_LANDINGPAD
%term BRG_FREEZE

# %term defind end

%declare<void> stmt<remniw::AsmBuilderPtr Builder>;
%declare<void> reg<remniw::AsmBuilderPtr Builder>;
%declare<void> imm<remniw::AsmBuilderPtr Builder>;
%declare<void> mem<remniw::AsmBuilderPtr Builder>;
%declare<void> label<remniw::AsmBuilderPtr Builder>;
%declare<void> cond<remniw::AsmBuilderPtr Builder>;
%declare<void> arg<remniw::AsmBuilderPtr Builder, unsigned ArgNo>;
%declare<void> args<remniw::AsmBuilderPtr Builder, unsigned ArgNo>;

%%

label: BRG_LABEL { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: label: BRG_LABEL\n";);
};

imm: BRG_CONST { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: imm: BRG_CONST\n";);
};

reg: BRG_REG { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_REG\n";);
};

mem: BRG_ALLOCA { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: mem: BRG_ALLOCA\n";);
};

reg: BRG_LOAD(mem) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_LOAD(mem)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    remniw::AsmOperand::RegOp Reg =
        Builder->handleLOAD($1->getInstruction(), $2->getAsAsmOperandMem());
    $0->setReg(Reg);
};

reg: BRG_LOAD(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_LOAD(reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    remniw::AsmOperand::RegOp Reg =
        Builder->handleLOAD($1->getInstruction(), $2->getAsAsmOperandReg());
    $0->setReg(Reg);
};

stmt: reg { $cost[0].cost = $cost[1].cost; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: reg\n";);
    $action[1](Builder);
};

stmt: BRG_RET(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_RET(reg)\n";);
    $action[2](Builder);
    Builder->handleRET($1->getInstruction(), $2->getAsAsmOperandReg());
};

stmt: BRG_RET(BRG_UNDEF) { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_RET(BRG_UNDEF)\n";);
};

stmt: BRG_RET(imm) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_RET(imm)\n";);
    $action[2](Builder);
    Builder->handleRET($1->getInstruction(), $2->getAsAsmOperandImm());
};

stmt: BRG_STORE(reg, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(reg, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandReg(),
                         $3->getAsAsmOperandMem());
};

stmt: BRG_STORE(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(reg, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandReg(),
                         $3->getAsAsmOperandReg());
};

stmt: BRG_STORE(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(imm, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandImm(),
                         $3->getAsAsmOperandReg());
};

stmt: BRG_STORE(imm, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(imm, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandImm(),
                         $3->getAsAsmOperandMem());
};

stmt: BRG_STORE(mem, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(mem, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto *SI = llvm::cast<llvm::StoreInst>($1->getInstruction());
    // In BrgTreeBuilder, we construct MemBrgTreeNode for argument.
    // So here we specially handle StoreInst which initializes
    // permanent storage for a function argument
    if (llvm::isa<llvm::Argument>(SI->getValueOperand())) {
        Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandMem(),
                             $3->getAsAsmOperandMem(),
                             /*bool DestIsArgument=*/true);
    } else {
        Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandMem(),
                             $3->getAsAsmOperandMem(),
                             /*bool DestIsArgument=*/false);
    }
};

stmt: BRG_STORE(label, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_STORE(label, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleSTORE($1->getInstruction(), $2->getAsAsmOperandLabel(),
                         $3->getAsAsmOperandMem());
};

mem: BRG_GETELEMENTPTR(mem, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    // For GetElementPtrInst, if all indices are constant we can calculate the MemOp
    // offset directly
    LLVM_DEBUG(llvm::outs() << "brg action: mem: BRG_GETELEMENTPTR(mem, imm)\n";);
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::MemOp Mem = Builder->handleGETELEMENTPTR(
        $1->getInstruction(), $2->getAsAsmOperandMem(), $3->getAsAsmOperandImm());
    $0->setMem(Mem);
};

mem: BRG_GETELEMENTPTR(mem, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: mem: BRG_GETELEMENTPTR(mem, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::MemOp Mem = Builder->handleGETELEMENTPTR(
        $1->getInstruction(), $2->getAsAsmOperandMem(), $3->getAsAsmOperandReg());
    $0->setMem(Mem);
};

mem: BRG_GETELEMENTPTR(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: mem: BRG_GETELEMENTPTR(reg, imm)\n";);
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::MemOp Mem = Builder->handleGETELEMENTPTR(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandImm());
    $0->setMem(Mem);
};

mem: BRG_GETELEMENTPTR(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: mem: BRG_GETELEMENTPTR(reg, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto *GEP = llvm::cast<llvm::GetElementPtrInst>($1->getInstruction());
    remniw::AsmOperand::MemOp Mem = Builder->handleGETELEMENTPTR(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandReg());
    $0->setMem(Mem);
};

cond: BRG_ICMP(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: cond: BRG_ICMP(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleICMP($1->getInstruction(), $2->getAsAsmOperandReg(),
                        $3->getAsAsmOperandReg());
};

cond: BRG_ICMP(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: cond: BRG_ICMP(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleICMP($1->getInstruction(), $2->getAsAsmOperandReg(),
                        $3->getAsAsmOperandImm());
};

cond: BRG_ICMP(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: cond: BRG_ICMP(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    Builder->handleICMP($1->getInstruction(), $2->getAsAsmOperandImm(),
                        $3->getAsAsmOperandReg());
};

# Conditional Branch
stmt: BRG_BR(cond, label, label)
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: stmt: BRG_BR(cond, label, label)\n";);
    $action[2](Builder);
    Builder->handleBR($1->getInstruction(), $3->getAsAsmOperandLabel(),
                      $4->getAsAsmOperandLabel());
};

# Unconditional Branch
stmt: BRG_BR(label, BRG_UNDEF, BRG_UNDEF) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(
        llvm::outs() << "brg action: stmt: BRG_BR(label, BRG_UNDEF, BRG_UNDEF)\n";);
    Builder->handleBR($1->getInstruction(), $2->getAsAsmOperandLabel());
};

reg: BRG_ADD(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_ADD(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleADD(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_ADD(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_ADD(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleADD(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandImm());
    $0->setReg(Reg);
};

reg: BRG_ADD(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_ADD(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleADD(
        $1->getInstruction(), $2->getAsAsmOperandImm(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_ADD(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_ADD(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("Unexpected action: reg: BRG_ADD(imm, imm)!\n");
};

reg: BRG_SUB(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SUB(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSUB(
        $1->getInstruction(), $2->getAsAsmOperandImm(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_SUB(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SUB(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSUB(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandImm());
    $0->setReg(Reg);
};

reg: BRG_SUB(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SUB(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSUB(
        $1->getInstruction(), $2->getAsAsmOperandImm(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_SUB(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SUB(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("Unexpected action reg: BRG_SUB(imm, imm)\n");
};

reg: BRG_MUL(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_MUL(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleMUL(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_MUL(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_MUL(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleMUL(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandImm());
    $0->setReg(Reg);
};

reg: BRG_MUL(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_MUL(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleMUL(
        $1->getInstruction(), $2->getAsAsmOperandImm(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_MUL(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_MUL(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("Unexpected action reg: BRG_MUL(imm, imm)\n");
};

reg: BRG_SDIV(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SDIV(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSDIV(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_SDIV(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SDIV(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSDIV(
        $1->getInstruction(), $2->getAsAsmOperandReg(), $3->getAsAsmOperandImm());
    $0->setReg(Reg);
};

reg: BRG_SDIV(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SDIV(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    remniw::AsmOperand::RegOp Reg = Builder->handleSDIV(
        $1->getInstruction(), $2->getAsAsmOperandImm(), $3->getAsAsmOperandReg());
    $0->setReg(Reg);
};

reg: BRG_SDIV(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_SDIV(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("Unexpected action reg: BRG_SDIV(imm, imm)!\n");
};

arg: reg { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: arg: reg\n";);
    $action[1](Builder);
    Builder->handleARG(ArgNo, $1->getAsAsmOperandReg());
};

arg: imm { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: arg: imm\n";);
    $action[1](Builder);
    Builder->handleARG(ArgNo, $1->getAsAsmOperandImm());
};

arg: mem { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: arg: mem\n";);
    $action[1](Builder);
    Builder->handleARG(ArgNo, $1->getAsAsmOperandMem());
};

arg: label { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: arg: label\n";);
    $action[1](Builder);
    Builder->handleARG(ArgNo, $1->getAsAsmOperandLabel());
};

args: BRG_ARGS(BRG_UNDEF, BRG_UNDEF) { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: args: BRG_ARGS(BRG_UNDEF, BRG_UNDEF)\n";);
};

args: BRG_ARGS(arg, args)  { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: args: BRG_ARGS(arg, args)\n";);
    $action[2](Builder, ArgNo);
    $action[3](Builder, ArgNo + 1);
};

# Direct Call
reg: BRG_CALL(label, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_CALL(label, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    remniw::AsmOperand::RegOp Reg =
        Builder->handleCALL($1->getInstruction(), $2->getAsAsmOperandLabel());
    $0->setReg(Reg);
};

# Indirect Call
reg: BRG_CALL(reg, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_CALL(reg, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    remniw::AsmOperand::RegOp Reg =
        Builder->handleCALL($1->getInstruction(), $2->getAsAsmOperandReg());
    $0->setReg(Reg);
};

# Indirect call
reg: BRG_CALL(mem, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: reg: BRG_CALL(mem, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    remniw::AsmOperand::RegOp Reg =
        Builder->handleCALL($1->getInstruction(), $2->getAsAsmOperandMem());
    $0->setReg(Reg);
};

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) { }

static void gen(NODEPTR p, remniw::AsmBuilder *Builder) {
    if (burm_label(p) == 0) {
        LLVM_DEBUG(llvm::outs() << "gen: " << "no cover\n";);
    } else {
        stmt_action(p->getState(), Builder);
    }
    burm_free(p->getState());
}


static void printDebugTree(BrgTreeNode *p, int indent=0) {
    if (!p)
        return;
    LLVM_DEBUG({
        if (indent) llvm::outs() << "|";
        int i = 0;
        for (; i < indent - 4; ++i) llvm::outs() << " ";
        if (indent - 4 > 0) llvm::outs() << "|";
        for (; i < indent; ++i) llvm::outs() << "-";
        llvm::outs() << "+ op:" << p->getOp() << ", Kind:" << p->getNodeKindString() << "\n";
        for(auto *kid: p->getKidsVector())
            printDebugTree(kid, (indent+4));
    });
}

namespace remniw {

void AsmBuilder::buildAsmFunction(const BrgFunction *BrgFunc) {
    CurrentFunction = new AsmFunction(BrgFunc->FuncName, BrgFunc->StackSizeInBytes);
    AsmFunctions.push_back(CurrentFunction);

    for (auto* RootNode: BrgFunc->Insts) {
        printDebugTree(RootNode);
        // FIXME: Label Instruction
        if (RootNode->getOp() == BrgTerm::Label)
            handleLABEL(AsmOperand::createLabel(RootNode->getLabel()));
        gen(RootNode, this);
    }
}

}  // namespace remniw
